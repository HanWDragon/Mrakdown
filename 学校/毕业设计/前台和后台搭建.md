# 后台准备工作

- 再IDEA完成字体和自动编译和自动导入的步骤
- 使用maven来管理微服务项目
- 创建好会员模块后，再添加日志模块
	- 这里注意logback的配置文件优的名称是logback.xml有的是logback-spring.xml
- 这里设置路由路径是为了后续微服务做**路由转发**，将接口带/member的请求都转发到member模块 `server.servlet.context-path=/member`
- 在AOP中设置对应的切点，保护隐私和监听方法执行参数和执行时间
- 创建公共模块，记得resource目录下创建config目录放置配置文件，不然文件冲突，优先级比放在resource目录下低
- 再来创建网关模块，注意gateway并不需要依赖别的模块，gateway是基于netty开发的，不需要引入common模块，和web依赖
- 当生产发布时，只有gateway需要配置外网ip，其余模块只需要开放内网访问，保证应用安全
- 通过配置gateway的VM参数来让gateway来打印日志
- `-Dreactor.netty.http.server.accessLogEnabled=true`

# gateway模块的开发

- 在其中开发拦截请求
# member模块的开发

- 开发人员统计模块
- 开发注册模块
- 定义请求实体类和通用返回值类
- 增加统一异常处理，以及添加自己定义的异常类，以及不打印堆栈信息
- 添加校验框架
- 使用雪花算法生成成员ID，自增ID只适合于小型单体应用，不适合数据库，不适合分库分表
- UUID是无序的，一堆无序ID构建有序索引，性能有问题
- 添加注册&登录模块（后面自己添加发送短信的功能）
- 跨域是前后端不可避免的问题，我们在网关模块配置
- 需要注意前后端参数传递，到底是表单还是json
- 实现单点登录
	- 两种主要实现方案
	- redis + token（内部数据只是作为键来查询）
	- jwt（token有意义，是用户信息加密）这次开发使用这种
	- 但是jwt也存在问题就是
	- token被解密（加盐值，每个项目的盐值不能一样）
	- token被第三方使用（对用户的操作进行监控，风险账号限流）
- 完成乘车人增删改查，为后面的代码生成器做准备（了解前后端单表增删改查的开发）
	- 设计对应的表，在持久层添加对应的代码生成对应的代码
	- 在插入数据时有一些数据是存储在Token的，要是每次都解析token太麻烦了，于是就需要拦截当前登录用户的数据放在线程本地变量，在member模块都能拿到数据
	- 然后就是编写前端代码和对应接口
	- 完成对应的代码
- 完成火车基础数据管理功能：车站、车次、车厢、座位
	- 我们之前一直写的前端界面都是针对客户端开发的，我们要开发管理员模块



## 雪花算法

### 原理
![](image/Pasted%20image%2020230906120405.png)

### 使用需要解决的问题

#### 数据中心，机器ID如何设置

- 利用Redis自增序列
- 利用数据库，为每台机器分配workID，保存ID和机器IP的关系

#### 时钟回拔

- 机器时间是3点，但是北京时间是2点，如果把机器的时间往回拔，那么2～3点的ID会重复生成
- 直接使用备用服务器，等时间过去就好了，通常都会有运维来管理服务器时间，这个问题不大，一般服务器时间离标准时间差几毫秒都会造成业务事故

# business模块的开发

- 看git提交记录

# batch模块的开发

- 看git记录

# 代码生成器

- 自制前后端代码生成器，快速开发
- 以乘车人增删改查为模板，自制单表管理前后端生成器
	- 生成controller、service、req、resp、enum.js
	- 了解freemarker
	- 学会写自己的生成器可用于导出复制excel、页面静态化等
- 由于只有generator模块需要这个于是只添加依赖到这个模块
- 我们要梳理一下文件顺序然后在开始书写
	- 首先是pom.xml，我们需要获取到需要读取的文件信息，因为我们可能有多个数据库对应着多个模块，所以需要知道读取的文件生成对应的模块
	- ![](image/Pasted%20image%2020231230130646.png)
	- 知道要读取对应的文件，就去读取对应持久层xml文件得到表名和实体名
	- ![](image/Pasted%20image%2020231230142155.png)
	- 得到了必要的参数，书写好了对应了ftl，就可以开始生成

# 数据库准备工作

- 本地数据库和云数据库都可以，但是推荐云数据库
- 重点：专库专用，忌用root（权限太大了，很容易操作到别的库）
- 新增数据库train，新增用户train，配置权限只能访问train数据库
- 再添加Mybatis和JBDC的依赖，并添加Mybatis配置文件
- 不建议使用plus，在流程中使用代码生成器，其实也没太大差别
- 开发规范，代码生成器生成的代码不可以修改，代码生成器只能生成单表的增删改查
- 如果需要书写自己的SQL，要写到自己定义的mapper，不能放到生成的mapper

# SQL表的介绍

- member 是注册用户信息记录表，可以为自己买票也可以为别人买票
```sql
drop table if exists `member`;
create table `member` (
  `id` bigint not null comment 'id',
  `mobile` varchar(11) comment '手机号',
  primary key (`id`),
  unique key `mobile_unique` (`mobile`)
) engine=innodb default charset=utf8mb4 comment='会员';
```

- passenger 是乘车人的信息，里面的枚举类型和自己实现的代码生成器有关，这个新增时间和修改时间是方便查看对应信息，还有datetime（3）是精确到毫秒
```sql
drop table if exists `passenger`;
create table `passenger` (
  `id` bigint not null comment 'id',
  `member_id` bigint not null comment '会员id',
  `name` varchar(20) not null comment '姓名',
  `id_card` varchar(18) not null comment '身份证',
  `type` char(1) not null comment '旅客类型|枚举[PassengerTypeEnum]',
  `create_time` datetime(3) comment '新增时间',
  `update_time` datetime(3) comment '修改时间',
  primary key (`id`),
  index `member_id_index` (`member_id`)
) engine=innodb default charset=utf8mb4 comment='乘车人';
```
# 前端准备工作以及搭建

## 搭建

- Vue CLI 5 + Vue 3 + Ant Design Vue 3

# 微服务的一些说明

## Nacos

![](image/Pasted%20image%2020240407010731.png)

- 使用版本2.23
- Nacos也是基于Spring的
- 支持数据库，默认不保存数据库
- 重点是`nacos.core.auth.plugin.nacos.token.secret.key=`这个是空的，使用32位的字符串做base64，记得复制等号，修改配置文件即可
- 其他的问题看文档
- dataId = 注册中心名字-配置文件启用名字.文件扩展名
```yaml
# 这是Spring Cloud alibaba 的配置文件  
  
spring:  
  # 注册中心的名字  
  application:  
    name: member  
  # 启动环境，nacos会根据环境读不同的配置dataId：member-dev.properties  
  profiles:  
    active: dev  
  ## nacos server注册中心地址  
  cloud:  
    nacos:  
      # 服务器地址  
      server-addr: 127.0.0.1:8848  
      config:  
        # nacos 命名空间  
        namespace: train  
        file-extension: properties
```
- `spring.profiles.active=dev` 这个控制着启动选择的配置文件
- Nacos的命名空间本来就是做项目/模块隔离而不是，针对不同的配置文件隔离，在相同的配置环境下，通过 `spring.profiles.active` 做环境隔离
- Nacos 挂了没有问题，这个有个心跳机制，而且在第一次服务被发现了，每个模块本地就会存储对应的信息、
# 缓存

![](image/Pasted%20image%2020240407184508.png)

## mybatis 一级缓存

- 多次调用同一个方法
- 多节点问题
- 加了事务就默认缓存，要参数和方法一样
- 能有效避免重复查询带来的性能影响
- 这个有 session 和 statement，范围不同
```text
# 配置为statement，即关闭一级缓存
mybatis.configuration.local-cache-scope=statement
```

##  mybatis 二级缓存

- 多次调用同一个接口，参数没有变化
- 直接在Mapper的XML中添加 `<cache></cache>` ,而且需要将对应实体类进行序列化
- 每个Mapper对应的缓存都是不一样的，同一个Mapper才有缓存
- 让二级缓存失效，就执行增删改就行，会将同一个命名空间的二级缓存清空
- 多节点问题

## SpringBoot内置缓存

- 添加对应的依赖，在配置类添加 `EnableCaching` 开启，使用注解使用，这个是针对参数使用equals和hashcode来看参数是否变动
- 使用时配合 `CachePut` 和 `Cacheable` 
- 如果你要放空值，去配置文件设置 `spring.cache.redis.cache-null-values = true`
- 多节点问题

## Redis

1. 提高访问速度，mysql 2K QPS redis 100K QPS
2. 解决多节点共享缓存

### 缓存击穿

- 一个热点的Key失效，大量请求直接访问数据库
	- 解决方法就是增加定时任务，在失效之前访问数据库，主动刷新缓存
- 如果是redis寄了，那还是会访问数据库
	- 解决方法就是分布式锁，谁拿到锁谁就去查数据库，其他请求就快速失败

### 缓存穿透

- 缓存为空，还是要查数据库
	- 解决方法就是分布式锁，只允许一个进来，更新缓存，如果查询数据为空，也放到缓存里面
### 缓存雪崩

- 大量的热点key同时失效，可以考虑不同的缓存过期策略
	- TTL 超时时间
	- LRU 最近最少使用
	- LFU 最近最不经常使用
	- FIFO 先进先出
	- Random 随机淘汰策略
	- 主动更新热点key缓存
	- 及时加了分布式锁，也是针对相同参数的查询，要是同一时间大量不同参数的请求进来 ，数据库压力还是大，于是我们要进行限流
### 生产问题

![](image/Pasted%20image%2020240407202930.png)

- 因为年轻代满了，多次回收后还在，去了老年代
- 解决办法就是去掉本地缓存，使用线程本地变量 

## 前端缓存

- 在前端很多时候页面都有很多重复信息，我们可以使用前端缓存来减轻服务器压力，就最开始访问时去调用接口

# Seata

- 详情看官网

![](image/Pasted%20image%2020240407212620.png)

# 分布式锁解决超卖

## Jmeter

- 支持中文，在 bin 目录下 jmeter.properties 修改为 language=zh_CN
- 修改 sampleresult.default.encoding=UTF-8 避免乱码

## synchronized和分布式锁的区别

- synchronized 只能解决单机锁的问题，并不可以解决多机问题，还是会出现超卖

## 分布式锁的问题及演进

分布式锁常见的问题：没拿到锁的线程把别人的锁删了，解法有 2 种  
* 1. 不管咋样都先上锁，加锁不要放在 try 里  
* 2. 加锁时，将当前线程 ID 放到锁对应的 Value中，删除时先去获取 Value，一致才能删除

红锁，获得半数占有

分布式锁一定要和核心逻辑在一起，不要分开，即使使用了 MQ 在MQ 消费消息时处理同一个车次的票还是要上分布式锁，使用令牌大闸（本质也是分布式锁）是限制机器人和最大人数，而且令牌校验通过后需保存订单信息，之后等待 MQ 消费

当获取了令牌大闸，可能无法成功获取分布式锁，此时就会失败，需要加入排队的机制防止令牌大闸过度消耗，也就是针对 MQ 中同一个车次的消息进行消费，此时就申请了一次分布式锁
# sentinel

- 介绍看文档去
- 限流是在被调用方，熔断是在调用方
- 这个不怎么复杂

## 常见的限流算法

- 静态窗口限流
- 动态窗口限流
- 漏桶限流
- 令牌桶限流
- 令牌大闸

## 为什么要使用令牌大闸

- 分布式锁和限流都不能解决机器人刷票的问题，1000个请求，900个限流快速失败，可能另外100个人都是同一个机器人在刷票
- 这种令牌可以分细一点，比如大家都抢一等座，可能把令牌抢光了，也可以令牌多设置一点
- 没有余票的时候，需要查库存才知道没有票，不如提前设置好令牌数量，这样提升性能
- 本质上还是分布式锁，不过和之前的锁不太一样，设置了看门狗但是并不需要结果，让这个令牌存在一段时间
# 在前端增加图片校验码

- 每次都要前端生成唯一的 token，每次都不能一样，用于贯验证码的生成和校验流程
- 防止一个用户输入的验证码，把别人的验证

# MQ异步削峰

- 主要是对一些复杂流程进行异步化，将一些简单的流程验证先执行，将费时的任务丢到 MQ 或者异步线程
- 通常都是采用 MQ，因为异步线程执行失败，数据就没了
- 后端通常设置轮询接口
- 记得 RocketMQ 记得调整 runbroker 里面的参数，里面的参数对于开发机还是太高了

```shell
set "JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g"
# 修改为
set "JAVA_OPT=%JAVA_OPT% -server -Xms256m -Xmx256m"
# 还需要配置环境变量
export NAMESRV_ADDR=localhost:9876
# 启动
bin\mqnamesrv.cmd
bin\mqbroker.cmd -n localhost:9876
```

## 时序图

### 基础购票

```mermaid
sequenceDiagram
    participant 用户
    participant 服务端
    用户->>服务端: 购票
    服务端->>服务端: 校验验证码，拿令牌大闸
    服务端->>服务端: 获取分布式锁
    服务端->>服务端: 选座购票
    服务端->>服务端: 释放分布式锁
    服务端-->>用户: 返回购票结果
```

### 使用异步线程

```mermaid
sequenceDiagram
    participant 用户
    participant 服务端
    用户->>服务端: 购票
    服务端->>服务端: 校验验证码，拿令牌大闸
    服务端-->>用户: 快速响应结果（成功/失败）
    服务端-->>服务端: 异步
    服务端->>服务端: 获取分布式锁
    loop 循环出票
    服务端->>服务端: 选座购票
    end
    服务端->>服务端: 释放分布式锁
    用户->>服务端: 轮询购票结果
    服务端-->>用户: 返回购票结果
```

### 使用MQ

```mermaid
sequenceDiagram
    participant 用户
    participant 服务端
    participant 出票模块
    用户->>服务端: 购票
    服务端->>服务端: 校验验证码，获取令牌大闸
    服务端->>出票模块: 提交消息到MQ
    服务端-->>用户: 快速响应结果（成功/失败）
    出票模块->>出票模块: 获取分布式锁
    loop 循环出票
    出票模块->>出票模块: 选座购票
    end
    出票模块->>出票模块: 释放分布式锁
    用户->>服务端: 等待一定时间轮询购票结果
    服务端-->>用户: 返回购票结果
```

# 压力测试

## 相关概念

![](image/Pasted%20image%2020250217155417.png)

![](image/Pasted%20image%2020250217160018.png)

## 测试

- 新代码 TPS 大概 450 左右
- 旧代码 TPS 大概 20 左右

## 最大并发数

1. 增加线程数，直到出现异常
2. 增加线程数，让平均响应时间超过预期

# 云上部署

## 架构图

![](image/Pasted%20image%2020250217182028.png)

## 部署时

- 使用 -Dspring.profiles.active=prod，不同的我们需要改动