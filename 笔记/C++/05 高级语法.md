# 面向对象

## 类

![](image/Pasted%20image%2020220919173622.png)

## 抽象

![](image/Pasted%20image%2020220919174334.png)

![](image/Pasted%20image%2020220919174646.png)

```cpp
#pragma once  
  
#include <iostream>  
using namespace std;  
  
class Complex {  
 public:  
  Complex();                            // 默认构造函数  
  Complex(double r, double i);          // 构造函数  
  virtual ~Complex();                   // 析构函数  
  Complex(const Complex &x);            // 拷贝构造  
  Complex &operator=(const Complex &c); // =号运算符  
  
  
  double GetReal() const { return _real; }  
  void SetReal(double d) { _real = d; }  
  double GetImage() const { return _image; }  
  void SetImage(double i) { _image = i; }  
  
  // 运算符重载  
  Complex operator+(const Complex &c) const;  
  Complex &operator+=(const Complex &c);  
  Complex operator-(const Complex &c) const;  
  Complex &operator-=(const Complex &c);  
  Complex operator*(const Complex &c) const;  
  Complex &operator*=(const Complex &c);  
  Complex operator/(const Complex &c) const;  
  Complex &operator/=(const Complex &c);  
  
  bool operator==(const Complex &c) const;  
  bool operator!=(const Complex &c) const;  
  bool operator>(const Complex &c) const;  
  bool operator>=(const Complex &c) const;  
  bool operator<(const Complex &c) const;  
  bool operator<=(const Complex &c) const;  
  
  // 前置和后置++  
  Complex &operator++();   //前置++  
  Complex operator++(int); //后置++  
  Complex &operator--();   //前置--  
  Complex operator--(int); //后置--  
  
//protected:  
  
  friend ostream &operator<<(ostream &os, const Complex &x);  
  friend istream &operator>>(istream &is, Complex &x);  
  
 private:  
  double _real;           // 复数的实部  
  double _image;         // 复数的虚部  
};
```

```cpp
Complex::Complex() {  
  _real = 0.0;  
  _image = 0.0;  
  //cout << "Complex::Complex()" << endl;  
}  
  
Complex::Complex(double r, double i) {  
  _real = r;  
  _image = i;  
  //cout << "Complex::Complex(double r, double i)" << endl;  
}  
  
Complex::Complex(const Complex &c) {  
  _real = c._real;  
  _image = c._image;  
  //cout << "Complex::Complex(const Complex& c)" << endl;  
}  
  
Complex &Complex::operator=(const Complex &c) {  
  if (this != &c) {  
    _real = c._real;  
    _image = c._image;  
  }  return *this;  
}  
  
Complex::~Complex() {  
  _real = _image = 0.0;  
  //cout << "Complex::~Complex()" << endl;  
}  
  
Complex Complex::operator+(const Complex &c) const {  
  //Complex tmp;  
  //tmp._real = _real + x._real;  //tmp._image = _image + x._image;  //return tmp;  
  return Complex(_real + c._real, _image + c._image);  
}  
  
Complex &Complex::operator+=(const Complex &c) {  
  _real += c._real;  
  _image += c._image;  
  
  return *this;  
}  
  
Complex Complex::operator-(const Complex &c) const {  
  return Complex(_real - c._real, _image - c._image);  
}  
  
Complex &Complex::operator-=(const Complex &c) {  
  _real -= c._real;  
  _image -= c._image;  
  
  return *this;  
}  
  
Complex Complex::operator*(const Complex &c) const {  
  return Complex(_real * c._real - _image * c._image, _real * c._image + _image * c._real);  
}  
  
Complex &Complex::operator*=(const Complex &c) {  
  Complex tmp(*this);
  _real = tmp._real * c._real - _image * c._image;  
  _image = tmp._real * c._image + tmp._image * c._real;  
  return *this;  
}  
  
Complex Complex::operator/(const Complex &c) const {  
  double t = c._real * c._real + c._image * c._image;  
  return Complex((_real * c._real - _image * (-c._image)) / t, (_real * (-c._image) + _image * c._real) / t);  
}  
  
Complex &Complex::operator/=(const Complex &c) {  
  Complex tmp(*this);
  double t = c._real * c._real + c._image * c._image;  
  _real = (tmp._real * c._real - tmp._image * (-c._image)) / t;  
  _image = (tmp._real * (-c._image) + tmp._image * c._real) / t;  
  return *this;  
}  
  
bool Complex::operator==(const Complex &c) const {  
  return (_real == c._real) && (_image == c._image);  
}  
  
bool Complex::operator!=(const Complex &c) const {  
  return !((_real == c._real) && (_image == c._image));  
}  
  
bool Complex::operator>(const Complex &c) const {  
  return (_real > c._real) && (_image > c._image);  
}  
  
bool Complex::operator>=(const Complex &c) const {  
  return (_real >= c._real) && (_image >= c._image);  
}  
  
bool Complex::operator<(const Complex &c) const {  
  return (_real < c._real) && (_image < c._image);  
}  
  
bool Complex::operator<=(const Complex &c) const {  
  return (_real <= c._real) && (_image <= c._image);  
}  
  
Complex &Complex::operator++()
{  
  _real++;  
  _image++;  
  return *this;  
}  
  
Complex Complex::operator++(int)
{  
  //Complex tmp(*this);  
  //_real++;  //_image++;  //return tmp;  return Complex(_real++, _image++);  
}  
  
Complex &Complex::operator--()
{  
  _real--;  
  _image--;  
  return *this;  
}  
  
Complex Complex::operator--(int)
{  
  return Complex(_real--, _image--);  
}  
  
ostream &operator<<(ostream &os, const Complex &x) {  
  os << "real value is  " << x._real << "  image value is " << x._image;  
  return os;  
}  
  
istream &operator>>(istream &is, Complex &x) {  
  is >> x._real >> x._image;  
  return is;  
}
```

# IO流

![](image/Pasted%20image%2020220920095523.png)

![](image/Pasted%20image%2020220920095811.png)

## IO缓存区

![](image/Pasted%20image%2020220920100038.png)

## 文件操作

 ![](image/Pasted%20image%2020220920102831.png)
![](image/Pasted%20image%2020220920103138.png)

![](image/Pasted%20image%2020220920105124.png)

# 深拷贝与浅拷贝，写时复制

![](image/Pasted%20image%2020220920212144.png)