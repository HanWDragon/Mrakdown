
![](image/Pasted%20image%2020250305220749.png)

# 什么变量大小是 0 字节

## 基本类型的字节数

![](image/Pasted%20image%2020250305221708.png)

## 空结构体

![](image/Pasted%20image%2020250305223959.png)

空结构体始终指向同一个地址,在 malloc.go 可以看到 zerobase

节省内存用法是 `m := map[string]struct{}{}` 这就是 HashSet，节省内存，然后就是使用 chan 发信号 `a := make(chan struct{})`

![](image/Pasted%20image%2020250305223449.png)

## 总结

![](image/Pasted%20image%2020250305224021.png)

## 代码

```go
package main  
  
import (  
    "fmt"  
    "unsafe")  
  
type Test struct {  
}  
  
type Test2 struct {  
    num1 Test  
    num2 int32  
}  
  
func main() {  
    fmt.Println("int 默认类型在64位机器上所占字节数", unsafe.Sizeof(0))  
    fmt.Println("uint 默认类型在64位机器上所占字节数", unsafe.Sizeof(uint(0)))  
    fmt.Println("int16 类型所占字节数", unsafe.Sizeof(int16(0)))  
    fmt.Println("int32 类型所占字节数", unsafe.Sizeof(int32(0)))  
    fmt.Println("int64 类型所占字节数", unsafe.Sizeof(int64(0)))  
    fmt.Println("-------------------------------------------------")  
    i := 1  
    p := &i  
    fmt.Println("指针类型所占字节数", unsafe.Sizeof(p))  
    fmt.Println("-------------------------------------------------")  
    a := Test{}  
    b := 1  
    c := Test{}  
    fmt.Println("空结构体类型 a 所占字节数", unsafe.Sizeof(a))  
    fmt.Printf("空结构体类型 a 地址：%p\n", &a)  
    fmt.Println("int 类型 b 所占字节数", unsafe.Sizeof(b))  
    fmt.Printf("int 类型 b 地址：%p\n", &b)  
    fmt.Println("空结构体类型所 c 占字节数", unsafe.Sizeof(c))  
    fmt.Printf("空结构体类型 c 地址：%p\n", &c)  
    fmt.Println("-------------------------------------------------")  
    d := Test2{}  
    fmt.Println("Zerobase 类型 a 所占字节数", unsafe.Sizeof(a))  
    fmt.Printf("Zerobase 地址：%p\n", &a)  
    fmt.Println("空结构体类型 d 所占字节数", unsafe.Sizeof(d))  
    fmt.Printf("空结构体类型 c 地址：%p\n", &d)  
}
```

# 数组、字符串、切片底层一样吗

## 字符串

![](image/Pasted%20image%2020250306093625.png)

![](image/Pasted%20image%2020250306093704.png)

```go
// 这就是字符串的结构体定义，所以符合下图中 16 字节的输出 8 + 8
// 默认 runtime 包是不对外开放，reflect 对外开放
package runtime

type stringStruct struct {  
    str unsafe.Pointer  
    len int  
}

package reflect

type StringHeader struct {  
    Data uintptr  // 也是 8 个字节，也是指针
    Len  int  
}
```

![](image/Pasted%20image%2020250305224510.png)

![](image/Pasted%20image%2020250305224919.png)

接下来看看结构体中 Len 的大小，为什么这和 Unicode 有关

```go
package main  
  
import (  
    "fmt"  
    "reflect"    "unsafe")  
  
func main() {  
    s := "Han"  
    sh := (*reflect.StringHeader)(unsafe.Pointer(&s))  
    s1 := "韩狗"  
    sh1 := (*reflect.StringHeader)(unsafe.Pointer(&s1))  
    fmt.Println("Han 所占有长度:", sh.Len)  // 3
    fmt.Println("韩狗所占有长度:", sh1.Len)  // 6
    fmt.Println("-------------------------------------------------")   
}
```

### Unicode

![](image/Pasted%20image%2020250306092936.png)

 ### UTF-8

![](image/Pasted%20image%2020250306093154.png)

### 字符串的访问

![](image/Pasted%20image%2020250306095826.png)

### 字符串的切分

![](image/Pasted%20image%2020250306095849.png)

### 代码


```go
package main  
  
import (  
    "fmt"  
    "reflect"    "unsafe")  
  
func main() {  
    s := "Han"  
    sh := (*reflect.StringHeader)(unsafe.Pointer(&s))  
    s1 := "韩狗"  
    sh1 := (*reflect.StringHeader)(unsafe.Pointer(&s1))  
    s2 := "韩狗ABC"  
    sh2 := (*reflect.StringHeader)(unsafe.Pointer(&s2))  
    fmt.Println("Han 所占有长度:", sh.Len)  
    fmt.Println("韩狗 所占有长度:", sh1.Len)  
    fmt.Println("韩狗ABC 所占有长度:", sh2.Len)  
    fmt.Println("-------------------------------------------------")  
    fmt.Println("Han 所占有长度:", len(s))  
    fmt.Println("韩狗 所占有长度:", len(s1))  
    fmt.Println("韩狗ABC 所占有长度:", len(s2))  
    fmt.Println("-------------------------------------------------")  
    for i := 0; i < len(s2); i++ {  
       fmt.Print(s2[i])  
       if i != len(s2)-1 {  
          fmt.Print(" ")  
       }  
    }  
    fmt.Println()  
    fmt.Println("-------------------------------------------------")  
    for _, str := range s2 {  
       fmt.Printf("%c ", str)  
    }  
}
```

## 切片

![](image/Pasted%20image%2020250306100345.png)

![](image/Pasted%20image%2020250306100452.png)

在 slice.go 

```go
type slice struct {  
    array unsafe.Pointer  
    len   int  
    cap   int  
}
```

### 如何创建

![](image/Pasted%20image%2020250306100625.png)

![](image/Pasted%20image%2020250306102415.png)

`len = 3，cap = 9`

![](image/Pasted%20image%2020250306102432.png)

#### 通过字面量

```go
package main  
  
import "fmt"  
  
func main() {  
    s := []int{1, 2, 3}  
    fmt.Println(s)  
}
```

使用 `go build -gcflags -S main.go` 查看生成的汇编，可以看到创建了数组，然后创建了一个 Object 这就是切片的结构体，三个变量塞入了结构体

```
main.main STEXT size=138 args=0x0 locals=0x40 funcid=0x0 align=0x0
        0x0000 00000 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     TEXT    main.main(SB), ABIInternal, $64-0
        0x0000 00000 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     CMPQ    SP, 16(R14)
        0x0004 00004 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     PCDATA  $0, $-2
        0x0004 00004 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     JLS     124
        0x0006 00006 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     PCDATA  $0, $-1
        0x0006 00006 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     PUSHQ   BP
        0x0007 00007 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     MOVQ    SP, BP
        0x000a 00010 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     SUBQ    $56, SP
        0x000e 00014 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     FUNCDATA        $0, gclocals·ISb46fRPFoZ9pIfykFK/kQ==(SB)
        0x000e 00014 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     FUNCDATA        $1, gclocals·y8m7lvuFiYH+34CaepokTw==(SB)
        0x000e 00014 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     FUNCDATA        $2, main.main.stkobj(SB)
        0x000e 00014 (/Users/hwl/GolandProjects/Go-Redis/main.go:6)     LEAQ    type:[3]int(SB), AX
        0x0015 00021 (/Users/hwl/GolandProjects/Go-Redis/main.go:6)     PCDATA  $1, $0
        0x0015 00021 (/Users/hwl/GolandProjects/Go-Redis/main.go:6)     CALL    runtime.newobject(SB)
        0x001a 00026 (/Users/hwl/GolandProjects/Go-Redis/main.go:6)     MOVQ    $1, (AX)
        0x0021 00033 (/Users/hwl/GolandProjects/Go-Redis/main.go:6)     MOVQ    $2, 8(AX)
        0x0029 00041 (/Users/hwl/GolandProjects/Go-Redis/main.go:6)     MOVQ    $3, 16(AX)
        0x0031 00049 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     MOVUPS  X15, main..autotmp_10+40(SP)
        0x0037 00055 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     MOVL    $3, BX
        0x003c 00060 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     MOVQ    BX, CX
        0x003f 00063 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     PCDATA  $1, $1
        0x003f 00063 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     NOP
        0x0040 00064 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     CALL    runtime.convTslice(SB)

这里就是创建数组的汇编

        0x0045 00069 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     LEAQ    type:[]int(SB), CX
        0x004c 00076 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     MOVQ    CX, main..autotmp_10+40(SP)
        0x0051 00081 (/Users/hwl/GolandProjects/Go-Redis/main.go:7)     MOVQ    AX, main..autotmp_10+48(SP)
        0x0056 00086 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   MOVQ    os.Stdout(SB), BX
        0x005d 00093 (<unknown line number>)    NOP

        0x005d 00093 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   LEAQ    go:itab.*os.File,io.Writer(SB), AX
        0x0064 00100 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   LEAQ    main..autotmp_10+40(SP), CX
        0x0069 00105 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   MOVL    $1, DI
        0x006e 00110 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   MOVQ    DI, SI
        0x0071 00113 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   PCDATA  $1, $0
        0x0071 00113 (/usr/local/opt/go/libexec/src/fmt/print.go:314)   CALL    fmt.Fprintln(SB)
        0x0076 00118 (/Users/hwl/GolandProjects/Go-Redis/main.go:8)     ADDQ    $56, SP
        0x007a 00122 (/Users/hwl/GolandProjects/Go-Redis/main.go:8)     POPQ    BP
        0x007b 00123 (/Users/hwl/GolandProjects/Go-Redis/main.go:8)     RET
        0x007c 00124 (/Users/hwl/GolandProjects/Go-Redis/main.go:8)     NOP
        0x007c 00124 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     PCDATA  $1, $-1
        0x007c 00124 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     PCDATA  $0, $-2
        0x007c 00124 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     NOP
        0x0080 00128 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     CALL    runtime.morestack_noctxt(SB)
        0x0085 00133 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     PCDATA  $0, $-1
        0x0085 00133 (/Users/hwl/GolandProjects/Go-Redis/main.go:5)     JMP     0

```

#### 通过 make


```go
package main  
  
import "fmt"  
  
func main() {  
    s := make([]int, 3)  
    fmt.Println(s)  
}
```


通过  `go build -gcflags -S main.go` 生成汇编看到了调用 makeslice 方法

![](image/Pasted%20image%2020250306102239.png)

![](image/Pasted%20image%2020250306102118.png)

### 切片的访问

![](image/Pasted%20image%2020250306102533.png)

### 切片的追加

编译器直接处理，运行时直接创建好

 ![](image/Pasted%20image%2020250306102715.png)

直接创建新数组，通常是原来长度的 2 倍

![](image/Pasted%20image%2020250306103005.png)

图中只是大致逻辑，具体请以代码为准

![](image/Pasted%20image%2020250306103230.png)

```go
// nextslicecap computes the next appropriate slice length.
func nextslicecap(newLen, oldCap int) int {  
    newcap := oldCap  
    doublecap := newcap + newcap  
    if newLen > doublecap {  
       return newLen  
    }  
  
    const threshold = 256  
    if oldCap < threshold {  
       return doublecap  
    }  
    for {  
       // Transition from growing 2x for small slices  
       // to growing 1.25x for large slices. This formula       
       // gives a smooth-ish transition between the two.       
       newcap += (newcap + 3*threshold) >> 2  
  
       // We need to check `newcap >= newLen` and whether `newcap` overflowed.  
       // newLen is guaranteed to be larger than zero, hence       
       // when newcap overflows then `uint(newcap) > uint(newLen)`.  
       // This allows to check for both with the same comparison.       
       if uint(newcap) >= uint(newLen) {  
          break  
       }  
    }  
  
    // Set newcap to the requested cap when  
    // the newcap calculation overflowed.    
    if newcap <= 0 {  
       return newLen  
    }  
    return newcap  
}
```

### 总结

![](image/Pasted%20image%2020250306104319.png)

# Map

Redis 本来就是一个巨大的 HashMap 

## HashMap 的基本方案

![](image/Pasted%20image%2020250306104514.png)

### 开放寻址法

![](image/Pasted%20image%2020250306104718.png)

### 拉链法

![](image/Pasted%20image%2020250306104811.png)

## Go 的 Map

![](image/Pasted%20image%2020250306112914.png)

最多装 8 个，多了在溢出指针指向，元素都是 8 个一组

![](image/Pasted%20image%2020250306113211.png)

runtime 下的 map_noswiss.go hmap 结构体

```go
// A header for a Go map.  
type hmap struct {  
    // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.    
    // Make sure this stays in sync with the compiler's definition.    
    count     int  // # live cells == size of map.  Must be first (used by len() builtin)  
    flags     uint8  
    B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)  
    noverflow uint16  // approximate number of overflow buckets; see incrnoverflow for details    
	hash0     uint32   // hash seed  
  
    buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.  
    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing  
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)  
    clearSeq   uint64  
  
    extra *mapextra // optional fields  
}
```

## Map 的初始化

 ![](image/Pasted%20image%2020250306114604.png)
### make

![](image/Pasted%20image%2020250306113211.png)

![](image/Pasted%20image%2020250306115058.png)

数量较小就会调用不同函数

![](image/Pasted%20image%2020250306114515.png)

![](image/Pasted%20image%2020250306114725.png)

```go
//go:linkname makemap  
func makemap(t *maptype, hint int, h *hmap) *hmap {  
    mem, overflow := math.MulUintptr(uintptr(hint), t.Bucket.Size_)  
    if overflow || mem > maxAlloc {  
       hint = 0  
    }  
  
    // initialize Hmap  
    if h == nil {  
       h = new(hmap)  
    }  
    h.hash0 = uint32(rand())  
  
    // Find the size parameter B which will hold the requested # of elements.  
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.    
    B := uint8(0)  
    for overLoadFactor(hint, B) {  
       B++  
    }  
    h.B = B  
  
    // allocate initial hash table  
    // if B == 0, the buckets field is allocated lazily later (in mapassign)    // If hint is large zeroing this memory could take a while.    
    if h.B != 0 {  
       var nextOverflow *bmap  
       h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)  
       if nextOverflow != nil {  
          h.extra = new(mapextra)  
          h.extra.nextOverflow = nextOverflow  
       }  
    }  
  
    return h  
}  
  
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.  
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and  
// otherwise dirtyalloc will be cleared and reused as backing array.  
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {  
    base := bucketShift(b)  
    nbuckets := base  
    // For small b, overflow buckets are unlikely.  
    // Avoid the overhead of the calculation.    
    if b >= 4 {  
       // Add on the estimated number of overflow buckets  
       // required to insert the median number of elements       
       // used with this value of b.       
       nbuckets += bucketShift(b - 4)  
       sz := t.Bucket.Size_ * nbuckets  
       up := roundupsize(sz, !t.Bucket.Pointers())  
       if up != sz {  
          nbuckets = up / t.Bucket.Size_  
       }  
    }  
  
    if dirtyalloc == nil {  
       buckets = newarray(t.Bucket, int(nbuckets))  
    } else {  
       // dirtyalloc was previously generated by  
       // the above newarray(t.Bucket, int(nbuckets))       
       // but may not be empty.       
       buckets = dirtyalloc  
       size := t.Bucket.Size_ * nbuckets  
       if t.Bucket.Pointers() {  
          memclrHasPointers(buckets, size)  
       } else {  
          memclrNoHeapPointers(buckets, size)  
       }  
    }  
  
    if base != nbuckets {  
       // We preallocated some overflow buckets.  
       // To keep the overhead of tracking these overflow buckets to a minimum,       
       // we use the convention that if a preallocated overflow bucket's overflow       
       // pointer is nil, then there are more available by bumping the pointer.       
       // We need a safe non-nil pointer for the last overflow bucket; just use buckets.       
       nextOverflow = (*bmap)(add(buckets, base*uintptr(t.BucketSize)))  
       last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.BucketSize)))  
       last.setoverflow(t, (*bmap)(buckets))  
    }  
    return buckets, nextOverflow  
}
```

### 字面量

![](image/Pasted%20image%2020250306115413.png)

## Map 的访问

![](image/Pasted%20image%2020250306113211.png)

### 计算桶号

![](image/Pasted%20image%2020250306115931.png)

![](image/Pasted%20image%2020250306120021.png)

### 计算 tophash

![](image/Pasted%20image%2020250306120129.png)

### 查找匹配

![](image/Pasted%20image%2020250306120346.png)

## Map 的写入

![](image/Pasted%20image%2020250306120453.png)

## Map 的扩容

### 哈希碰撞

总结来说就是计算出来的哈希相同并不代表要插入的元素相等，当桶的数量太少，碰撞发生的十分频繁，时间复杂度从 `o(1) -> o(log2(n))` 最极端就退化成链表，导致性能严重下降


```go
// Did not find mapping for key. Allocate new cell & add entry.  
  
// If we hit the max load factor or we have too many overflow buckets,  
// and we're not already in the middle of growing, start growing.  
if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {  
    hashGrow(t, h)  
    goto again // Growing the table invalidates everything, so try again  
}
```

![](image/Pasted%20image%2020250306121545.png)

![](image/Pasted%20image%2020250306121312.png)

### 扩容类型

![](image/Pasted%20image%2020250306121655.png)

等量是因为，曾经很多，但是后面删除了许多，导致很多元素都在溢出桶，但是溢出桶内元素很少，这就需要重新整理

### 扩容步骤一

 ![](image/Pasted%20image%2020250306122340.png)

![](image/Pasted%20image%2020250306122442.png)


```go
func hashGrow(t *maptype, h *hmap) {
	// If we've hit the load factor, get bigger.
	// Otherwise, there are too many overflow buckets,
	// so keep the same number of buckets and "grow" laterally.
	bigger := uint8(1)
	if !overLoadFactor(h.count+1, h.B) {
		bigger = 0
		h.flags |= sameSizeGrow
	}
	oldbuckets := h.buckets
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)

	flags := h.flags &^ (iterator | oldIterator)
	if h.flags&iterator != 0 {
		flags |= oldIterator
	}
	// commit the grow (atomic wrt gc)
	h.B += bigger
	h.flags = flags
	h.oldbuckets = oldbuckets
	h.buckets = newbuckets
	h.nevacuate = 0
	h.noverflow = 0

	if h.extra != nil && h.extra.overflow != nil {
		// Promote current overflow buckets to the old generation.
		if h.extra.oldoverflow != nil {
			throw("oldoverflow is not nil")
		}
		h.extra.oldoverflow = h.extra.overflow
		h.extra.overflow = nil
	}
	if nextOverflow != nil {
		if h.extra == nil {
			h.extra = new(mapextra)
		}
		h.extra.nextOverflow = nextOverflow
	}

	// the actual copying of the hash table data is done incrementally
	// by growWork() and evacuate().
}
```

### 扩容步骤二

![](image/Pasted%20image%2020250306122858.png)

这里使用 B 来计算新桶很巧妙，多一位也就是 1/0 要么去原来同一个位置要么去新的位置，在修改时完成驱逐，读取还是原来的地方

![](image/Pasted%20image%2020250306123217.png)

![](image/Pasted%20image%2020250306123026.png)

h.growing() 就说明在扩容，里面的 goWork 就调用了 evacuate 方法

```go
// Like mapaccess, but allocates a slot for the key if it is not present in the map.
//
// mapassign should be an internal detail,
// but widely used packages access it using linkname.
// Notable members of the hall of shame include:
//   - github.com/bytedance/sonic
//   - github.com/RomiChan/protobuf
//   - github.com/segmentio/encoding
//   - github.com/ugorji/go/codec
//
// Do not remove or change the type signature.
// See go.dev/issue/67401.
//
//go:linkname mapassign
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
	if h == nil {
		panic(plainError("assignment to entry in nil map"))
	}
	if raceenabled {
		callerpc := sys.GetCallerPC()
		pc := abi.FuncPCABIInternal(mapassign)
		racewritepc(unsafe.Pointer(h), callerpc, pc)
		raceReadObjectPC(t.Key, key, callerpc, pc)
	}
	if msanenabled {
		msanread(key, t.Key.Size_)
	}
	if asanenabled {
		asanread(key, t.Key.Size_)
	}
	if h.flags&hashWriting != 0 {
		fatal("concurrent map writes")
	}
	hash := t.Hasher(key, uintptr(h.hash0))

	// Set hashWriting after calling t.hasher, since t.hasher may panic,
	// in which case we have not actually done a write.
	h.flags ^= hashWriting

	if h.buckets == nil {
		h.buckets = newobject(t.Bucket) // newarray(t.Bucket, 1)
	}

again:
	bucket := hash & bucketMask(h.B)
	if h.growing() {
		growWork(t, h, bucket)
	}
	b := (*bmap)(add(h.buckets, bucket*uintptr(t.BucketSize)))
	top := tophash(hash)

	var inserti *uint8
	var insertk unsafe.Pointer
	var elem unsafe.Pointer
bucketloop:
	for {
		for i := uintptr(0); i < abi.OldMapBucketCount; i++ {
			if b.tophash[i] != top {
				if isEmpty(b.tophash[i]) && inserti == nil {
					inserti = &b.tophash[i]
					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.KeySize))
					elem = add(unsafe.Pointer(b), dataOffset+abi.OldMapBucketCount*uintptr(t.KeySize)+i*uintptr(t.ValueSize))
				}
				if b.tophash[i] == emptyRest {
					break bucketloop
				}
				continue
			}
			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.KeySize))
			if t.IndirectKey() {
				k = *((*unsafe.Pointer)(k))
			}
			if !t.Key.Equal(key, k) {
				continue
			}
			// already have a mapping for key. Update it.
			if t.NeedKeyUpdate() {
				typedmemmove(t.Key, k, key)
			}
			elem = add(unsafe.Pointer(b), dataOffset+abi.OldMapBucketCount*uintptr(t.KeySize)+i*uintptr(t.ValueSize))
			goto done
		}
		ovf := b.overflow(t)
		if ovf == nil {
			break
		}
		b = ovf
	}

	// Did not find mapping for key. Allocate new cell & add entry.

	// If we hit the max load factor or we have too many overflow buckets,
	// and we're not already in the middle of growing, start growing.
	if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
		hashGrow(t, h)
		goto again // Growing the table invalidates everything, so try again
	}

	if inserti == nil {
		// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
		newb := h.newoverflow(t, b)
		inserti = &newb.tophash[0]
		insertk = add(unsafe.Pointer(newb), dataOffset)
		elem = add(insertk, abi.OldMapBucketCount*uintptr(t.KeySize))
	}

	// store new key/elem at insert position
	if t.IndirectKey() {
		kmem := newobject(t.Key)
		*(*unsafe.Pointer)(insertk) = kmem
		insertk = kmem
	}
	if t.IndirectElem() {
		vmem := newobject(t.Elem)
		*(*unsafe.Pointer)(elem) = vmem
	}
	typedmemmove(t.Key, insertk, key)
	*inserti = top
	h.count++

done:
	if h.flags&hashWriting == 0 {
		fatal("concurrent map writes")
	}
	h.flags &^= hashWriting
	if t.IndirectElem() {
		elem = *((*unsafe.Pointer)(elem))
	}
	return elem
}

func growWork(t *maptype, h *hmap, bucket uintptr) {  
    // make sure we evacuate the oldbucket corresponding  
    // to the bucket we're about to use    evacuate(t, h, bucket&h.oldbucketmask())  
  
    // evacuate one more oldbucket to make progress on growing  
    if h.growing() {  
       evacuate(t, h, h.nevacuate)  
    }  
}
```

### 扩容步骤三

![](image/Pasted%20image%2020250306124213.png)

![](image/Pasted%20image%2020250306124228.png)

## Map 的并发问题

![](image/Pasted%20image%2020250306125215.png)

![](image/Pasted%20image%2020250306125247.png)

![](image/Pasted%20image%2020250306125311.png)

下面代码运行后 `fatal error: concurrent map read and map write`

```go
func main() {  
  
    m := make(map[int]int)  
    go func() {  
       for {  
          _ = m[1]  
       }  
    }()  
  
    go func() {  
       for {  
          m[2] = 2  
       }  
    }()  
  
    select {}  
}
```

### 如何解决

![](image/Pasted%20image%2020250306125348.png)

### sync.Map

![](image/Pasted%20image%2020250306125615.png)

正常读写不涉及到扩容，只有追加才会涉及到扩容，这里就是普通读写和追加分离，并不是像 Java 的 CopyOnWriteArrayList

#### 正常读写

![](image/Pasted%20image%2020250306125940.png)

#### 追加

 amended 修改后代表有数据追加到 dirty map ，有数据查询不到时去 dirty 查询

![](image/Pasted%20image%2020250306130401.png)

#### 追加后读写

每次 m 中没有命中，在下面找到，要修改 misses 代表 dirty 命中

![](image/Pasted%20image%2020250306130818.png)

#### dirty 提升

![](image/Pasted%20image%2020250306131334.png)

![](image/Pasted%20image%2020250306131429.png)

![](image/Pasted%20image%2020250306131528.png)

#### 删除

![](image/Pasted%20image%2020250306131658.png)

##### 正常删除

![](image/Pasted%20image%2020250306131835.png)

![](image/Pasted%20image%2020250306131857.png)

 ![](image/Pasted%20image%2020250306131917.png)

##### 追加后删除

这个时候也是直接删除，但是有个问题就是删除后提升，提升之后该如何处理

![](image/Pasted%20image%2020250306132029.png)

![](image/Pasted%20image%2020250306132306.png)

##### 追加删除后提升 dirty

这样直接就在 m 里清除就好了，不用管下面

![](image/Pasted%20image%2020250306132443.png)

## 总结

![](image/Pasted%20image%2020250306120631.png)

![](image/Pasted%20image%2020250306124245.png)

![](image/Pasted%20image%2020250306132755.png)

# 接口

## Go 隐式接口特点

![](image/Pasted%20image%2020250306133026.png)

## 接口值底层表示

![](image/Pasted%20image%2020250306150422.png)

接口也有类型，和实现接口的结构体不是同一个类型，有专门的表示在 runtime 包下 runtime2.go 文件定义，下方代码中 Truck 就被 data 这个指针所指向

```go 
type iface struct {  
    tab  *itab  
    data unsafe.Pointer  
}

// The first word of every non-empty interface type contains an *ITab.  
// It records the underlying concrete type (Type), the interface type it  
// is implementing (Inter), and some ancillary information.  
//  
// allocated in non-garbage-collected memory  
type ITab struct {  
    Inter *InterfaceType  
    Type  *Type  
    Hash  uint32     // copy of Type.Hash. Used for type switches.  
    Fun   [1]uintptr // variable sized. fun[0]==0 means Type does not implement Inter.  
}  
  
// EmptyInterface describes the layout of a "interface{}" or a "any."// These are represented differently than non-empty interface, as the first  
// word always points to an abi.Type.  
type EmptyInterface struct {  
    Type *Type  
    Data unsafe.Pointer  
}
```

```go
package main  
  
import "fmt"  
  
func main() {  
    var c Car = Truck{"Truck"}  
    fmt.Println(c)  
}  
  
type Car interface {  
    Drive()  
}  
  
type Truck struct {  
    Model string  
}  
  
func (t Truck) Drive() {  
    fmt.Println("Truck drive")  
}
```

## 类型断言

![](image/Pasted%20image%2020250306150454.png)

```go
package main  
  
import "fmt"  
  
func main() {  
    var c Car = Truck{"Truck"}  
    truck := c.(Truck)  
    trafficTools := c.(TrafficTools)  
    fmt.Println(c)  
    fmt.Println(truck)  
    fmt.Println(trafficTools)  
    switch trafficTools.(type) {  
    case Truck:  
       fmt.Println("Truck")  
    case Car:  
       fmt.Println("Car")  
    case TrafficTools:  
       fmt.Println("TrafficTools")  
    }  
}  
  
type TrafficTools interface {  
    Drive()  
}  
  
type Car interface {  
    Drive()  
}  
  
type Truck struct {  
    Model string  
}  
  
func (t Truck) Drive() {  
    fmt.Println("Truck drive")  
}
```

## 结构体和指针实现接口

编译器默认添加使用指针实现的方法，编写时可不用声明，可以用  `go build -gcflags -S main.go` 来查看编译器提供的代码

![](image/Pasted%20image%2020250306151418.png)

## 空接口值

![](image/Pasted%20image%2020250306152931.png)

承接任何数据是因为，编译器帮你把传入的参数通过 eface 包装好了

```go
// EmptyInterface describes the layout of a "interface{}" or a "any."
// These are represented differently than non-empty interface, as the first  
// word always points to an abi.Type.  
type EmptyInterface struct {  
    Type *Type  
    Data unsafe.Pointer  
}
```

### 用途

![](image/Pasted%20image%2020250306153130.png)

## 总结

![](image/Pasted%20image%2020250306153207.png)

# nil、空接口、空结构体

## nil

![](image/Pasted%20image%2020250306154701.png)

定义中 nil 是个变量，可以看注释来理解，表示 `pointer, channel, func, interface, map, or slice `  类型的 0 值

```go
// nil is a predeclared identifier representing the zero value for a
// pointer, channel, func, interface, map, or slice type.
var nil Type // Type must be a pointer, channel, func, interface, map, or slice type
```

```go
package main  
  
import "fmt"  
  
func main() {  
    var a *int  
    fmt.Println(a == nil)  
    var b map[int]int  
    fmt.Println(b == nil)  
    //var c struct{}  
    //fmt.Println(c == nil) // Cannot convert 'nil' to type 'struct{}'    var d interface{}  
    fmt.Println(d == nil)  
    //fmt.Println(a == b) // Invalid operation: a == b (mismatched types *int and map[int] int)  
}
```

## 空结构体

![](image/Pasted%20image%2020250306154925.png)

```go
package main  
  
import "fmt"  
  
func main() {  
    var a *struct{} = &struct{}{}  
    fmt.Println(a == nil)  
    var b *struct{}  
    fmt.Println(b == nil)  
    //var c struct {}  
    //fmt.Println(c == nil) // Cannot convert 'nil' to type 'struct{}'}
```

## 空接口

![](image/Pasted%20image%2020250306160358.png)

因为空接口表示是 eface ，原来就是都为 nil 但是当又了 a =  c ，虽然 data 为 nil，但是类型有数值了为 `*int` ，所以不为空

空接口可能数据为空，但是类型不为空，只有两个属性都为 nil 才是空接口

```go
package main  
  
import "fmt"  
  
func main() {  
    var a interface{}  
    var b interface{}  
    var c *int  
    fmt.Println(a == nil)  
    fmt.Println(b == nil)  
    fmt.Println(c == nil)  
    fmt.Println("------------------------------------")  
    a = c  
    fmt.Println(a == nil)  
    fmt.Printf("%p\n", &a)  
  
}
```

## 总结

![](image/Pasted%20image%2020250306160423.png)

# 内存对齐

![](image/Pasted%20image%2020250306161134.png)

```go
package main  
  
import (  
    "fmt"  
    "unsafe")  
  
type Test1 struct {  
    num1 int32  
    num2 int32  
}  
  
type Test2 struct {  
    num1 int16  
    num2 int32  
}  
  
func main() {  
    fmt.Println(unsafe.Sizeof(Test1{})) // 8  
    fmt.Println(unsafe.Sizeof(Test2{})) // 8  
}
```

## 非内存对齐

CPU 访问数据按字长来访问，访问都是整 8 个字节来访问

![](image/Pasted%20image%2020250306161400.png)

![](image/Pasted%20image%2020250306161203.png)

![](image/Pasted%20image%2020250306161235.png)

## 内存对齐

![](image/Pasted%20image%2020250306162115.png)

## 对齐系数

![](image/Pasted%20image%2020250306162214.png)
 
```go
package main  
  
import (  
    "fmt"  
    "unsafe")  
  
func main() {  
    fmt.Printf("bool size:%d align: %d\n", unsafe.Sizeof(bool(true)), unsafe.Alignof(bool(true)))  
    fmt.Printf("byte size:%d align: %d\n", unsafe.Sizeof(byte(0)), unsafe.Alignof(byte(0)))  
    fmt.Printf("int8 size:%d align: %d\n", unsafe.Sizeof(int8(0)), unsafe.Alignof(int8(0)))  
    fmt.Printf("int16 size:%d align: %d\n", unsafe.Sizeof(int16(0)), unsafe.Alignof(int16(0)))  
    fmt.Printf("int32 size:%d align: %d\n", unsafe.Sizeof(int32(0)), unsafe.Alignof(int32(0)))  
    fmt.Printf("int64 size:%d align: %d\n", unsafe.Sizeof(int64(0)), unsafe.Alignof(int64(0)))  
}
```

## 结构体对齐

 ![](image/Pasted%20image%2020250306164655.png)
### 结构体内部对齐

![](image/Pasted%20image%2020250306164837.png)

![](image/Pasted%20image%2020250306164851.png)

![](image/Pasted%20image%2020250306165054.png)

### 结构体长度填充

![](image/Pasted%20image%2020250306165504.png)

![](image/Pasted%20image%2020250306164851.png)

![](image/Pasted%20image%2020250306165536.png)

### 节约结构体空间

![](image/Pasted%20image%2020250306165710.png)

### 结构体对齐系数

![](image/Pasted%20image%2020250306165905.png)

### 空结构体对齐

![](image/Pasted%20image%2020250306170028.png)

![](image/Pasted%20image%2020250306170051.png)

## 总结

![](image/Pasted%20image%2020250306170154.png)

# 本篇小结

## 变量长度

![](image/Pasted%20image%2020250306170436.png)

## 内存对齐

![](image/Pasted%20image%2020250306170452.png)

## 字符串和切片

![](image/Pasted%20image%2020250306170541.png)

## Map

![](image/Pasted%20image%2020250306170701.png)

![](image/Pasted%20image%2020250306115058.png)

### 扩容

![](image/Pasted%20image%2020250306170759.png)

### sync.Map

![](image/Pasted%20image%2020250306170820.png)

## 接口

![](image/Pasted%20image%2020250306170846.png)

## nil、空接口、空结构体

![](image/Pasted%20image%2020250306170912.png)